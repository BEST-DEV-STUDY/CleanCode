### 자료 추상화
- 변수사이에 함수를 넣는다고 구현이 감춰지는 것이 아니고, 추상화를 통해 구현을 숨겨야 한다.
- 변수를 private으로 선언하더라도 각 값마다 getter와 setter를 제공한다면 구현을 외부로 노출하는 것과 같다.

**구현을 외부로 노출한 예시**
```java
public interface Vehicle {
  double getFuelTankCapacityInGallons();
  double getGallonsOfGasoline();
}
```

**구현을 완전히 숨긴 예시**
```java
public interface Vehicle {
  double getPercentFuelRemaining();
}
```
목적은 남은 연료의 퍼센테이지를 아는 것이고 해당 목적을 위해 연료의 종류나, 구체적인 리터양은 추상화되어도 되는 정보이다.

### 자료/객체 비대칭
-   객체는 추상화하고 자료를 다루는 함수만 공개한다.
-   자료 구조는 자료를 그대로 공개, 추가로 다루는 함수는 따로 제공하지 않는다.
-  객체 지향(객체 사용)에서 어려운 변경은 절차지향(자료구조 사용)에서 쉽고, 절차지향에서 어려운 변경은 객체지향에서 쉽다.

###디미터 법칙

- 추상화를 하기 위해 지켜야 할 법칙으로, 메소드가 반환하는 객체의 메소드를 사용하면 안 된다.
- 디미터 법칙을 지키지 않을 때는 “기차충돌"이 일어나게 된다.

기차 충돌이 일어난 코드
```
String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

해당 코드는 임시 디렉토리의 절대경로를 가지고 오고 있다. 좀 더 내부를 살펴보면 목적은 임시파일을 생성하기 위함이다. 따라서 객체에게 임시파일을 생성하라고 시키고, 임시디렉토리의 절대경로를 가져오는 것은 임시파일을 생성하는 방법이므로 숨겨야 한다.


### 잡종 구조

절반은 객체, 절반은 자료 구조인 잡종 구조.

-   공개 변수, 공개 함수, 주요 함수, getter, setter 모두 섞여 있는 구조
-   양쪽의 단점만 있는 구조로 새로운 함수는 물론, 새로운 자료 구조도 추가하기 어렵다.

### 자료 전달 객체

**_DTO_**

공개 변수만 있고 함수가 없는 클래스

**_Bean_**

비공개 변수와 getter, setter가 있는 클래스, 저자는 bean 이 별다른 이득이 없다고 말한다.

**활성  레코드**

공개, 비공개 변수와 getter, setter, 그리고 find 와 같은 탐색 함수가 있는 클래스 => 비지니스 로직이 있으면 안된다.


### 결론

객체와 자료구조의 책임을 명확하게 하고, 각각 에 맞는 역할을 맡기자.

